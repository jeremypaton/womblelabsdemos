<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Thanos Splat - Womble Labs</title>
  
  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-XXXXXXXXXX');
  </script>
  
  <style>
    body {
      margin: 0;
      /* Default cursor set via JavaScript for better control - 128x128 with finger tip hotspot */
      cursor: url('./assets/cursor/thanos_point_128.png') 32 16, pointer;
    }

    header {
      position: absolute;
      color: silver;
      font-family: sans-serif;
      padding: 20px;
      text-align: center;
      width: 100vw;
      z-index: 100;
      background: rgba(0, 0, 0, 0.8);
    }

    canvas {
      cursor: inherit;
    }

  </style>
</head>

<body>
  <header>THANOS SPLAT<br>point at an object to select and click to delete<br><small>WASD to move, Q/E/↑↓ for up/down, ←→ for left/right</small><br><small>defeat all 3 infinity drop bears, then end the universe with one more snap</small></header>
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.178.0/three.module.js",
        "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.9/spark.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from "three";
    import { SplatMesh, PackedSplats, dyno } from "@sparkjsdev/spark";


    async function init() {
    // Set default cursor immediately, then preload for better reliability
    document.body.style.cursor = `url('./assets/cursor/thanos_point_128.png') 32 16, pointer`;
    
    // Preload cursor to ensure it's cached
    const defaultCursorImg = new Image();
    defaultCursorImg.onload = () => {
      console.log('Default cursor preloaded successfully');
      // Re-apply cursor after preload to ensure it shows
      document.body.style.cursor = `url('./assets/cursor/thanos_point_128.png') 32 16, pointer`;
    };
    defaultCursorImg.onerror = () => {
      console.error('Failed to load default cursor, using fallback');
      document.body.style.cursor = 'pointer';
    };
    defaultCursorImg.src = './assets/cursor/thanos_point_128.png';
    
    // Animation time for shader effects
    const animateT = dyno.dynoFloat(0);
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
    camera.position.set(0.25, 0.05, 0.6);
    // camera.lookAt removed to preserve natural camera rotation like index.html
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', onWindowResize, false);
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Camera movement controls
    const keys = {};
    const moveSpeed = 0.05;
    
    // Track key states
    window.addEventListener('keydown', (event) => {
      keys[event.code] = true;
    });
    
    window.addEventListener('keyup', (event) => {
      keys[event.code] = false;
    });
    
    // Update camera position based on keys
    function updateCameraMovement() {
      // WASD movement
      if (keys['KeyW']) {
        camera.position.z -= moveSpeed; // Move forward
      }
      if (keys['KeyS']) {
        camera.position.z += moveSpeed; // Move backward
      }
      if (keys['KeyA']) {
        camera.position.x -= moveSpeed; // Move left
      }
      if (keys['KeyD']) {
        camera.position.x += moveSpeed; // Move right
      }
      
      // Q/E and Arrow keys for up/down movement
      if (keys['KeyQ'] || keys['ArrowUp']) {
        camera.position.y += moveSpeed; // Move up
      }
      if (keys['KeyE'] || keys['ArrowDown']) {
        camera.position.y -= moveSpeed; // Move down
      }
      
      // Left/Right arrows for horizontal movement
      if (keys['ArrowLeft']) {
        camera.position.x -= moveSpeed; // Move left
      }
      if (keys['ArrowRight']) {
        camera.position.x += moveSpeed; // Move right
      }
    }

    // Load forest background first
    console.log("Loading forest.ply file...");
    let forestMesh = null;
    
    try {
      // Load the forest PLY file using Spark.js PackedSplats
      const forestSplatURL = "./assets/forest.ply";
      const forestPackedSplats = new PackedSplats({ url: forestSplatURL });
      
      // Wait for the forest splats to load
      await forestPackedSplats.ready;
      console.log("Forest PLY file loaded successfully");
      
      // Create forest mesh
      forestMesh = new SplatMesh({ packedSplats: forestPackedSplats });
      forestMesh.rotation.x = Math.PI;
      forestMesh.scale.setScalar(1.0); // Keep forest at full scale
      forestMesh.position.set(0, 0, 0); // Position at origin
      
      // Add disintegration capability to forest
      forestMesh.disintegrateIntensity = dyno.dynoFloat(0);
      forestMesh.disintegrateTime = dyno.dynoFloat(0);
      forestMesh.disintegrateStartTime = 0;
      forestMesh.isDisintegrating = false;
      forestMesh.clickedTimer = 0;
      
      // Add forest disintegration shader
      forestMesh.objectModifier = dyno.dynoBlock(
        { gsplat: dyno.Gsplat },
        { gsplat: dyno.Gsplat },
        ({ gsplat }) => {
          const d = new dyno.Dyno({
            inTypes: { 
              gsplat: dyno.Gsplat, 
              t: "float", 
              intensity: "float"
            },
            outTypes: { gsplat: dyno.Gsplat },
            globals: () => [
              dyno.unindent(`
                // Multi-octave noise function for natural variation
                vec3 hash(vec3 p) {
                  return fract(sin(p*123.456)*123.456);
                }
                
                float noise(vec3 p) {
                  vec3 i = floor(p);
                  vec3 f = fract(p);
                  f = f * f * (3.0 - 2.0 * f);
                  
                  return mix(
                    mix(mix(dot(hash(i + vec3(0,0,0)), f - vec3(0,0,0)),
                            dot(hash(i + vec3(1,0,0)), f - vec3(1,0,0)), f.x),
                        mix(dot(hash(i + vec3(0,1,0)), f - vec3(0,1,0)),
                            dot(hash(i + vec3(1,1,0)), f - vec3(1,1,0)), f.x), f.y),
                    mix(mix(dot(hash(i + vec3(0,0,1)), f - vec3(0,0,1)),
                            dot(hash(i + vec3(1,0,1)), f - vec3(1,0,1)), f.x),
                        mix(dot(hash(i + vec3(0,1,1)), f - vec3(0,1,1)),
                            dot(hash(i + vec3(1,1,1)), f - vec3(1,1,1)), f.x), f.y), f.z);
                }

                vec4 disintegrate(vec3 pos, float t, float intensity) {
                  // Calculate relative bounding box Y (equivalent to VEX relbbox.y) - using estimated bounds
                  float relbboxY = (pos.y + 0.5) / 1.0; // Assumes bbox from -0.5 to 0.5
                  relbboxY += noise(pos * 4.0 + t * 0.3);
                  t = max(0.0,(t * 0.3) - relbboxY*0.3 - 0.4);
                  // Create dissolve pattern that moves from bottom to top
                  float dissolveHeight = mix(-2.0, 2.0, intensity);
                  float dissolveProgress = smoothstep(dissolveHeight - 0.5, dissolveHeight + 0.5, pos.y);
                  
                  // Add noise variation to the dissolve pattern
                  float noiseVariation = noise(pos * 8.0 + t * 0.5) * 0.3;
                  dissolveProgress += noiseVariation;
                  dissolveProgress = clamp(dissolveProgress, 0.0, 1.0);
                  
                  // Wind direction: up and to the right (like Thanos effect)
                  vec3 windDirection = vec3(1.5, 1.0, 0.2); // Right, up, slight forward
                  
                  // Add turbulent noise to wind for natural variation
                  vec3 turbulence = vec3(
                    noise(pos * 4.0 + t * 0.8),
                    noise(pos * 3.0 + t * 0.6 + 100.0),
                    noise(pos * 5.0 + t * 0.4 + 200.0)
                  ) * 2.0 - 1.0;
                  
                  // Combine wind direction with turbulence
                  vec3 finalWind = windDirection * 1.0;
                  
                  // Apply wind displacement based on dissolve progress
                  vec3 windOffset = -finalWind * pow(t,1.2);
                  vec3 newPos = pos + windOffset + pow(t,3.0) * turbulence * 2.0;
                  
                  // Fade out particles as they dissolve
                  float alpha = 1.0 - t;
                  
                  return vec4(newPos, alpha);
                }
              `)
            ],
            statements: ({ inputs, outputs }) => dyno.unindentLines(`
              ${outputs.gsplat} = ${inputs.gsplat};
              
              vec3 localPos = ${inputs.gsplat}.center;
              
              // Apply disintegration effect
              if (${inputs.intensity} > 0.0) {
                vec4 e = disintegrate(localPos, ${inputs.t}, ${inputs.intensity});
                ${outputs.gsplat}.center = e.xyz;
                
                // Scale particles smaller as they dissolve and fade
                float fadeAmount = 1.0 - e.w;
                ${outputs.gsplat}.scales = mix(${inputs.gsplat}.scales, vec3(.01, .01, .01), fadeAmount);
                
                // Use the alpha from the disintegration function
                ${outputs.gsplat}.rgba.a = ${inputs.gsplat}.rgba.a * e.w;
                
                // Add brief white flash when t < 0.05
                if (${inputs.t} > 0.3 && ${inputs.t} < 0.35 && ${inputs.intensity} > 0.0) {
                  float flashIntensity = 1.0 - ((${inputs.t}-0.3) / 0.05); // 1.0 at t=0, 0.0 at t=0.05
                  ${outputs.gsplat}.rgba.rgb = mix(${inputs.gsplat}.rgba.rgb, vec3(1.0, 1.0, 1.0), flashIntensity*0.7);
                }
              }
            `),
          });

          gsplat = d.apply({ 
            gsplat, 
            t: forestMesh.disintegrateTime,
            intensity: forestMesh.disintegrateIntensity
          }).gsplat;
          
          return { gsplat };
        }
      );
      
      scene.add(forestMesh);
      console.log("Forest mesh added to scene");
      console.log("Forest mesh properties:", {
        position: forestMesh.position,
        scale: forestMesh.scale,
        rotation: forestMesh.rotation,
        visible: forestMesh.visible
      });
      
    } catch (error) {
      console.error("Error loading forest PLY:", error);
      console.error("Forest loading failed, forestMesh will be null");
    }
    
    console.log("After forest loading attempt, forestMesh is:", forestMesh);

    // Add robots
    const NUM_ROBOTS = 3;
    const robots = [];
    let aliveBearsCount = NUM_ROBOTS; // Track how many bears are still alive
    
    // Load the local bear.ply file
    console.log("Loading local bear.ply file...");
    
    try {
      // Load the PLY file using Spark.js PackedSplats
      const splatURL = "./assets/bear.ply";
      const packedSplats = new PackedSplats({ url: splatURL });
      
      // Wait for the splats to load
      await packedSplats.ready;
      console.log("Bear PLY file loaded successfully");
      
      for (let i = 0; i < NUM_ROBOTS; i++) {
        const robot = new SplatMesh({ packedSplats });
        robot.rotation.x = Math.PI;
        robot.scale.setScalar(0.15); // Half the original size
        robot.position.set(0.25 + (i - 1) * 1.6, 0.05, -2.0); // Position in front of camera (negative Z)
        robot.baseX = 0.25 + (i - 1) * 1.6; // Store base X position for bobbing
        robot.speed = 600 + i * 10;
        robot.angle = 0;
        robot.clickedTimer = false;
        robot.disintegrateIntensity = dyno.dynoFloat(0); // Track disintegration effect
        robot.disintegrateTime = dyno.dynoFloat(0); // Individual time for this robot's disintegration
        robot.disintegrateStartTime = 0; // Track when disintegration started
        robot.isHovered = dyno.dynoFloat(0); // Track hover state for wobble effect
        // Bounding box will be passed as literal values
        
        // Add combined shader modifier (wobble + disintegration)
        robot.objectModifier = dyno.dynoBlock(
          { gsplat: dyno.Gsplat },
          { gsplat: dyno.Gsplat },
          ({ gsplat }) => {
            // First apply wobble effect for hover
            const wobble = new dyno.Dyno({
              inTypes: { 
                gsplat: dyno.Gsplat, 
                t: "float",
                hoverIntensity: "float"
              },
              outTypes: { gsplat: dyno.Gsplat },
              globals: () => [
                dyno.unindent(`
                  // Simple noise function for wobble
                  vec3 simpleHash(vec3 p) {
                    return fract(sin(p*123.456)*123.456);
                  }
                  
                  float simpleNoise(vec3 p) {
                    vec3 i = floor(p);
                    vec3 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    
                    return mix(
                      mix(mix(dot(simpleHash(i + vec3(0,0,0)), f - vec3(0,0,0)),
                              dot(simpleHash(i + vec3(1,0,0)), f - vec3(1,0,0)), f.x),
                          mix(dot(simpleHash(i + vec3(0,1,0)), f - vec3(0,1,0)),
                              dot(simpleHash(i + vec3(1,1,0)), f - vec3(1,1,0)), f.x), f.y),
                      mix(mix(dot(simpleHash(i + vec3(0,0,1)), f - vec3(0,0,1)),
                              dot(simpleHash(i + vec3(1,0,1)), f - vec3(1,0,1)), f.x),
                          mix(dot(simpleHash(i + vec3(0,1,1)), f - vec3(0,1,1)),
                              dot(simpleHash(i + vec3(1,1,1)), f - vec3(1,1,1)), f.x), f.y), f.z);
                  }

                  vec3 wobblePosition(vec3 pos, float t, float intensity) {
                    if (intensity <= 0.0) return pos;

                    vec3 npos = 0.1 * pos;
                    
                    float nt = t*10.0;
                    // Create turbulent wobble with multiple noise octaves - 10x higher frequency
                    vec3 wobble = vec3(
                      simpleNoise(npos * 80.0 + nt * 20.0),
                      simpleNoise(npos * 60.0 + nt * 15.0 + 100.0),
                      simpleNoise(npos * 100.0 + nt * 25.0 + 200.0)
                    ); // Zero-centered: [0,1] -> [-1,1]
                    
                    // Add some larger scale movement - also 10x higher frequency
                    // wobble += vec3(
                    //   simpleNoise(npos * 20.0 + t * 8.0),
                    //   simpleNoise(npos * 15.0 + t * 6.0 + 50.0),
                    //   simpleNoise(npos * 30.0 + t * 10.0 + 150.0)
                    // ) * 2.0 - 2.0; // Zero-centered: [0,1] -> [-1,1]
                    
                    // Ensure final wobble is zero-centered and scaled
                    return pos*1.1;// * (1.0+ wobble * intensity * 0.5); // wobble is already zero-centered
                  }
                `)
              ],
              statements: ({ inputs, outputs }) => dyno.unindentLines(`
                ${outputs.gsplat} = ${inputs.gsplat};
                
                // Apply wobble to position
                ${outputs.gsplat}.center = wobblePosition(${inputs.gsplat}.center, ${inputs.t}, ${inputs.hoverIntensity});
              `),
            });

            gsplat = wobble.apply({ 
              gsplat, 
              t: animateT,
              hoverIntensity: robot.isHovered
            }).gsplat;

            // Then apply disintegration effect
            const d = new dyno.Dyno({
              inTypes: { 
                gsplat: dyno.Gsplat, 
                t: "float", 
                intensity: "float"
              },
              outTypes: { gsplat: dyno.Gsplat },
              globals: () => [
                dyno.unindent(`
                  // Multi-octave noise function for natural variation
                  vec3 hash(vec3 p) {
                    return fract(sin(p*123.456)*123.456);
                  }
                  
                  float noise(vec3 p) {
                    vec3 i = floor(p);
                    vec3 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    
                    return mix(
                      mix(mix(dot(hash(i + vec3(0,0,0)), f - vec3(0,0,0)),
                              dot(hash(i + vec3(1,0,0)), f - vec3(1,0,0)), f.x),
                          mix(dot(hash(i + vec3(0,1,0)), f - vec3(0,1,0)),
                              dot(hash(i + vec3(1,1,0)), f - vec3(1,1,0)), f.x), f.y),
                      mix(mix(dot(hash(i + vec3(0,0,1)), f - vec3(0,0,1)),
                              dot(hash(i + vec3(1,0,1)), f - vec3(1,0,1)), f.x),
                          mix(dot(hash(i + vec3(0,1,1)), f - vec3(0,1,1)),
                              dot(hash(i + vec3(1,1,1)), f - vec3(1,1,1)), f.x), f.y), f.z);
                  }

                  vec4 disintegrate(vec3 pos, float t, float intensity) {
                    // Calculate relative bounding box Y (equivalent to VEX relbbox.y) - using estimated bounds
                    float relbboxY = (pos.y + 0.5) / 1.0; // Assumes bbox from -0.5 to 0.5
                    relbboxY += noise(pos * 4.0 + t * 0.3);
                    t = max(0.0,(t * 0.3) - relbboxY*0.3 - 0.4);
                    // Create dissolve pattern that moves from bottom to top
                    float dissolveHeight = mix(-2.0, 2.0, intensity);
                    float dissolveProgress = smoothstep(dissolveHeight - 0.5, dissolveHeight + 0.5, pos.y);
                    
                    // Add noise variation to the dissolve pattern
                    float noiseVariation = noise(pos * 8.0 + t * 0.5) * 0.3;
                    dissolveProgress += noiseVariation;
                    dissolveProgress = clamp(dissolveProgress, 0.0, 1.0);
                    
                    // Wind direction: up and to the right (like Thanos effect)
                    vec3 windDirection = vec3(1.5, 1.0, 0.2); // Right, up, slight forward
                    
                    // Add turbulent noise to wind for natural variation
                    vec3 turbulence = vec3(
                      noise(pos * 4.0 + t * 0.8),
                      noise(pos * 3.0 + t * 0.6 + 100.0),
                      noise(pos * 5.0 + t * 0.4 + 200.0)
                    ) * 2.0 - 1.0;
                    
                    // Combine wind direction with turbulence
                    vec3 finalWind = windDirection * 1.0;// + turbulence * 0.8;
                    
                    // Apply wind displacement based on dissolve progress
                    vec3 windOffset = -finalWind * pow(t,1.2);// * intensity * 2.0;
                    vec3 newPos = pos + windOffset + pow(t,3.0) * turbulence * 2.0;
                    
                    // Fade out particles as they dissolve
                    float alpha = 1.0 - t;// - dissolveProgress;
                    //alpha += pow(t*100.0,-2.0);
                    
                    return vec4(newPos, alpha);
                  }
                `)
              ],
              statements: ({ inputs, outputs }) => dyno.unindentLines(`
                ${outputs.gsplat} = ${inputs.gsplat};
                
                vec3 localPos = ${inputs.gsplat}.center;
                
                // Apply disintegration effect
                if (${inputs.intensity} > 0.0) {
                  vec4 e = disintegrate(localPos, ${inputs.t}, ${inputs.intensity});
                  ${outputs.gsplat}.center = e.xyz;
                  
                  // Scale particles smaller as they dissolve and fade
                  float fadeAmount = 1.0 - e.w;
                  ${outputs.gsplat}.scales = mix(${inputs.gsplat}.scales, vec3(.01, .01, .01), fadeAmount);
                  
                  // Use the alpha from the disintegration function
                  ${outputs.gsplat}.rgba.a = ${inputs.gsplat}.rgba.a * e.w;
                  
                  // Add brief white flash when t < 0.05
                  if (${inputs.t} > 0.3 && ${inputs.t} < 0.35 && ${inputs.intensity} > 0.0) {
                    float flashIntensity = 1.0 - ((${inputs.t}-0.3) / 0.05); // 1.0 at t=0, 0.0 at t=0.05
                    ${outputs.gsplat}.rgba.rgb = mix(${inputs.gsplat}.rgba.rgb, vec3(1.0, 1.0, 1.0), flashIntensity*0.7);
                  }
                }
              `),
            });

            gsplat = d.apply({ 
              gsplat, 
              t: robot.disintegrateTime,
              intensity: robot.disintegrateIntensity
            }).gsplat;
            
            return { gsplat };
          }
        );
        
        scene.add(robot);
        robots.push(robot);
      }
      console.log(`Created ${NUM_ROBOTS} bear splat meshes`);
      
    } catch (error) {
      console.error("Error loading bear PLY:", error);
      // Fallback: create simple spheres if PLY loading fails
      for (let i = 0; i < NUM_ROBOTS; i++) {
        const geometry = new THREE.SphereGeometry(0.1, 16, 16);
        const material = new THREE.MeshBasicMaterial({ 
          color: new THREE.Color().setHSL(i / NUM_ROBOTS, 0.7, 0.6)
        });
        const robot = new THREE.Mesh(geometry, material);
        robot.position.set(0.25 + (i - 1) * 1.6, 0.05, -2.0); // Position in front of camera (negative Z)
        robot.baseX = 0.25 + (i - 1) * 1.6; // Store base X position for bobbing
        robot.speed = 600 + i * 10;
        robot.angle = 0;
        robot.clickedTimer = false;
        robot.disintegrateIntensity = dyno.dynoFloat(0); // Track disintegration effect
        robot.disintegrateTime = dyno.dynoFloat(0); // Individual time for this robot's disintegration
        robot.disintegrateStartTime = 0; // Track when disintegration started
        robot.isHovered = dyno.dynoFloat(0); // Track hover state for wobble effect
        // Bounding box will be passed as literal values
        robot.recolor = { 
          set: (r, g, b, a = 1.0) => {
            robot.material.color.setRGB(r, g, b);
            robot.material.opacity = a;
            robot.material.transparent = a < 1.0;
          }
        };
        scene.add(robot);
        robots.push(robot);
      }
      console.log(`Created ${NUM_ROBOTS} fallback sphere meshes`);
    }

    // Cursor management with frame animation - 128x128 version
    let isSnapping = false;
    let snapFrameIndex = 0;
    let snapAnimationInterval = null;
    const totalSnapFrames = 25; // Now we have 25 frames
    
    // Purple flashing cursor for when all bears are dead
    let isFlashingPurple = false;
    let purpleFlashInterval = null;
    let purpleFlashState = false; // true = purple, false = normal
    
    function startPurpleFlashingCursor() {
      if (isFlashingPurple) return; // Already flashing
      
      console.log("Starting purple flashing cursor - all bears eliminated!");
      isFlashingPurple = true;
      purpleFlashState = false;
      
      // Flash between normal and purple cursor every 600ms (half speed)
      purpleFlashInterval = setInterval(() => {
        purpleFlashState = !purpleFlashState;
        if (purpleFlashState) {
          // Purple cursor - without screen filter effect
          document.body.style.cursor = `url('./assets/cursor/thanos_point_128.png') 32 16, pointer`;
        } else {
          // Normal cursor
          document.body.style.cursor = `url('./assets/cursor/thanos_point_128.png') 32 16, pointer`;
        }
      }, 600); // Flash every 600ms (half speed)
    }
    
    function stopPurpleFlashingCursor() {
      if (!isFlashingPurple) return;
      
      console.log("Stopping purple flashing cursor");
      isFlashingPurple = false;
      
      if (purpleFlashInterval) {
        clearInterval(purpleFlashInterval);
        purpleFlashInterval = null;
      }
      
      // Reset to normal cursor
      document.body.style.cursor = `url('./assets/cursor/thanos_point_128.png') 32 16, pointer`;
    }
    
    function startSnapCursor() {
      if (isSnapping) return; // Prevent multiple snaps
      
      // Temporarily stop purple flashing during snap animation
      const wasFlashingPurple = isFlashingPurple;
      if (isFlashingPurple) {
        stopPurpleFlashingCursor();
      }
      
      // Clear any existing interval first
      if (snapAnimationInterval) {
        clearInterval(snapAnimationInterval);
        snapAnimationInterval = null;
      }
      
      isSnapping = true;
      snapFrameIndex = 1; // Start with frame 1
      
      // Set initial frame - 128x128 with finger tip hotspot at 32,16
      document.body.style.cursor = `url('./assets/cursor/snap_frame_128_001.png') 32 16, pointer`;
      // Clear any filter during snap (no longer needed)
      
      // Animate through frames
      snapAnimationInterval = setInterval(() => {
        snapFrameIndex++;
        if (snapFrameIndex <= totalSnapFrames) {
          const frameNum = snapFrameIndex.toString().padStart(3, '0');
          document.body.style.cursor = `url('./assets/cursor/snap_frame_128_${frameNum}.png') 32 16, pointer`;
        } else {
          // Animation complete, return to appropriate cursor state
          clearInterval(snapAnimationInterval);
          snapAnimationInterval = null; // Clear the interval reference
          isSnapping = false;
          
          // Check if we should resume purple flashing or go to normal cursor
          if (aliveBearsCount === 0 && forestMesh && !forestMesh.isDisintegrating) {
            startPurpleFlashingCursor(); // Resume purple flashing if all bears are dead
          } else {
            document.body.style.cursor = `url('./assets/cursor/thanos_point_128.png') 32 16, pointer`;
          }
          console.log('Snap animation complete, cursor reset');
        }
      }, 80); // 80ms per frame for 25 frames = 2 second total animation
      
      // Fallback timeout to ensure cursor resets even if something goes wrong
      setTimeout(() => {
        if (isSnapping) {
          console.log('Fallback cursor reset triggered');
          if (snapAnimationInterval) {
            clearInterval(snapAnimationInterval);
            snapAnimationInterval = null;
          }
          document.body.style.cursor = `url('./assets/cursor/thanos_point_128.png') 32 16, pointer`;
          isSnapping = false;
        }
      }, 3000); // 3 second fallback (longer than the 2 second animation)
    }

    // Raycast logic
    const raycaster = new THREE.Raycaster();
    let hoveredObject = null;
    let currentMouseCoords = new THREE.Vector2();
    let mouseInCanvas = false;
    
    // Track mouse position for continuous raycasting
    renderer.domElement.addEventListener("mousemove", (event) => {
      // Adjust for cursor hotspot offset (finger tip is at 32,16, center would be 64,64)
      const offsetX = event.clientX - 32; // Move left by 32 pixels
      const offsetY = event.clientY - 48; // Move up by 48 pixels (64-16)
      
      currentMouseCoords.set(
        (offsetX / renderer.domElement.width) * 2 - 1,
        -(offsetY / renderer.domElement.height) * 2 + 1
      );
      mouseInCanvas = true;
    });
    
    // Track when mouse leaves canvas
    renderer.domElement.addEventListener("mouseleave", () => {
      mouseInCanvas = false;
      // Reset hover state when mouse leaves (only if bear still exists)
      if (hoveredObject && !hoveredObject.clickedTimer && robots.includes(hoveredObject)) {
        hoveredObject.recolor.set(1, 1, 1);
      }
      hoveredObject = null;
    });
    
    // Function to perform hover detection (called every frame)
    function updateHoverState() {
      if (!mouseInCanvas) return;
      
      // Run raycaster for hover detection
      raycaster.setFromCamera(currentMouseCoords, camera);
      const hits = raycaster.intersectObjects(scene.children);

      // Find first SplatMesh that's not the forest (only target robots)
      const index = hits.findIndex(hit => hit.object instanceof SplatMesh && robots.includes(hit.object));
      
      if (index >= 0) {
        const newHoveredObject = hits[index].object;
        
        // If we're hovering over a different object
        if (hoveredObject !== newHoveredObject) {
          // Reset previous hovered object (if not clicked and still exists)
          if (hoveredObject && !hoveredObject.clickedTimer && robots.includes(hoveredObject)) {
            hoveredObject.recolor.set(1, 1, 1); // Reset to white
            hoveredObject.isHovered.value = 0; // Stop wobble
          }
          
          // Set new hovered object to purple (if not clicked and not disintegrating)
          hoveredObject = newHoveredObject;
          if (!hoveredObject.clickedTimer && !hoveredObject.isDisintegrating) {
            // Blend purple with original white at 0.4 weight (40% purple, 60% white)
            const purpleWeight = 0.4;
            const r = 1.0 * (1 - purpleWeight) + 0.6 * purpleWeight;
            const g = 1.0 * (1 - purpleWeight) + 0.3 * purpleWeight;
            const b = 1.0 * (1 - purpleWeight) + 0.8 * purpleWeight;
            hoveredObject.recolor.set(r, g, b);
            hoveredObject.isHovered.value = 1.0; // Start wobble
          }
        }
      } else {
        // Not hovering over any robot
        if (hoveredObject && !hoveredObject.clickedTimer && robots.includes(hoveredObject)) {
          hoveredObject.recolor.set(1, 1, 1); // Reset to white
          hoveredObject.isHovered.value = 0; // Stop wobble
        }
        hoveredObject = null;
      }
    }

    // Click handler
    renderer.domElement.addEventListener("click", (event) => {
      // Start the snap cursor animation
      startSnapCursor();
      
      // Adjust for cursor hotspot offset (same as mousemove)
      const offsetX = event.clientX - 32; // Move left by 32 pixels
      const offsetY = event.clientY - 48; // Move up by 48 pixels (64-16)
      
      const clickCoords = new THREE.Vector2(
        (offsetX / renderer.domElement.width) * 2 - 1,
        -(offsetY / renderer.domElement.height) * 2 + 1,
      );

      // Run raycaster
      raycaster.setFromCamera(clickCoords, camera);
      const hits = raycaster.intersectObjects(scene.children);

      console.log(`Click detected. Alive bears: ${aliveBearsCount}, Forest exists: ${!!forestMesh}, Hits: ${hits.length}`);
      
      // Check if all bears are gone - if so, target the forest
      if (aliveBearsCount === 0 && forestMesh && !forestMesh.isDisintegrating) {
        console.log("All bears are gone, checking for forest hit...");
        // All bears are gone, target the forest
        const forestIndex = hits.findIndex(hit => hit.object === forestMesh);
        console.log(`Forest hit index: ${forestIndex}`);
        if (forestIndex >= 0) {
          console.log("All bears gone - disintegrating forest!");
          forestMesh.clickedTimer = 360; // Same timer as bears
          forestMesh.disintegrateIntensity.value = 0;
          forestMesh.isDisintegrating = true;
          forestMesh.disintegrateStartTime = 0;
          stopPurpleFlashingCursor(); // Stop purple flashing when forest starts disintegrating
        } else {
          console.log("Forest not hit, clicking anywhere should work when all bears gone");
          // Let's make it work by clicking anywhere when all bears are gone
          console.log("All bears gone - disintegrating forest!");
          forestMesh.clickedTimer = 360; // Same timer as bears
          forestMesh.disintegrateIntensity.value = 0;
          forestMesh.isDisintegrating = true;
          forestMesh.disintegrateStartTime = 0;
          stopPurpleFlashingCursor(); // Stop purple flashing when forest starts disintegrating
        }
      } else {
        // Find first SplatMesh that's a robot (not the forest)
        const index = hits.findIndex(hit => hit.object instanceof SplatMesh && robots.includes(hit.object));
        if (index >= 0) {
          const robot = hits[index].object;
          if (!robot.clickedTimer) {
            // Start disintegration effect and immediately decrement counter
            console.log(`Starting bear disintegration. Current alive count: ${aliveBearsCount}`);
            robot.clickedTimer = 360; // 3x longer timer for disintegration
            robot.disintegrateIntensity.value = 0; // Start from 0
            robot.isDisintegrating = true;
            robot.disintegrateStartTime = 0; // Will be set in animation loop
            robot.isHovered.value = 0; // Stop wobble when clicked
            
            // Decrement alive count immediately when disintegration starts
            aliveBearsCount--;
            console.log(`Bear marked for disintegration. Bears remaining: ${aliveBearsCount}`);
            
            // Start purple flashing cursor if all bears are now dead
            if (aliveBearsCount === 0) {
              setTimeout(() => {
                // Delay slightly to let snap animation finish first
                if (!isSnapping) {
                  startPurpleFlashingCursor();
                }
              }, 2500); // Wait for snap animation to complete
            }
          }
        }
      }
    });

    // Main loop
    renderer.setAnimationLoop(function animate(time) {
      // Update camera movement from keyboard input
      updateCameraMovement();
      
      // Update animation time for shaders
      animateT.value = time / 1000;
      
      // Debug: Log alive count periodically
      if (Math.floor(time / 1000) % 5 === 0 && time % 1000 < 50) { // Every 5 seconds
        console.log(`Current alive bears count: ${aliveBearsCount}, robots array length: ${robots.length}`);
      }
      
      // Animate all robots with bobbing motion, and handle disintegration
      // Use a copy of the robots array to avoid issues when removing items during iteration
      for (let i = robots.length - 1; i >= 0; i--) {
        const robot = robots[i];
        // Bobbing up and down motion (only if not disintegrating and not hovered)
        if (!robot.isDisintegrating && robot !== hoveredObject) {
          robot.position.y = Math.sin(time / robot.speed) * 0.3; // Bob up and down with 0.3 amplitude
          robot.position.x = robot.baseX; // Maintain horizontal position
        }
        
        // Slow inward spinning for left and right bears (not center)
        if (!robot.isDisintegrating) {
          if (robot.baseX < 0) {
            // Left bear - spin clockwise (positive rotation around Y axis)
            robot.rotation.y = (time / 5000) % (Math.PI * 2); // 5 second full rotation
          } else if (robot.baseX > 0) {
            // Right bear - spin counter-clockwise (negative rotation around Y axis)
            robot.rotation.y = -(time / 5000) % (Math.PI * 2); // 5 second full rotation
          }
          // Center bear (baseX === 0) doesn't spin
        }

        if (robot.clickedTimer > 0) {
          robot.clickedTimer -= 1;
          
          // Debug logging for bear timers
          if (robot.clickedTimer % 60 === 0) { // Log every 60 frames
            console.log(`Bear timer: ${robot.clickedTimer}, isDisintegrating: ${robot.isDisintegrating}`);
          }
          
          // Handle disintegration animation
          if (robot.isDisintegrating) {
            // Set start time on first frame of disintegration
            if (robot.disintegrateStartTime === 0) {
              robot.disintegrateStartTime = time / 1000;
            }
            
            // Update individual disintegration time (starts from 0 for each robot)
            robot.disintegrateTime.value = (time / 1000) - robot.disintegrateStartTime;
            
            // Animate disintegration intensity from 0 to 1
            const progress = 1 - (robot.clickedTimer / 360);
            robot.disintegrateIntensity.value = Math.min(progress * 1.5, 1.0);
            
            // Update shader
            if (robot.updateGenerator) {
              robot.updateGenerator();
            }
            if (robot.updateVersion) {
              robot.updateVersion();
            }
            
            if (robot.clickedTimer == 0) {
              // Disintegration complete - remove bear from scene and arrays (counter already decremented)
              console.log(`Bear timer reached 0, removing bear from scene and arrays.`);
              scene.remove(robot);
              const robotIndex = robots.indexOf(robot);
              console.log(`Robot index in array: ${robotIndex}`);
              if (robotIndex > -1) {
                robots.splice(robotIndex, 1); // Remove from robots array
                console.log(`Removed bear from robots array. New array length: ${robots.length}`);
              }
              console.log(`Bear permanently removed from scene. Current alive count: ${aliveBearsCount}`);
              
              // Clear hover state if this was the hovered object
              if (robot === hoveredObject) {
                hoveredObject = null;
              }
              
              // Skip any further processing for this robot
              continue;
            }
          } else if (robot.clickedTimer == 0) {
            // Non-disintegration timer expired, check hover state
            if (robot.recolor) {
              if (robot === hoveredObject && !robot.isDisintegrating) {
                // Blend purple with original white at 0.4 weight (40% purple, 60% white)
                const purpleWeight = 0.4;
                const r = 1.0 * (1 - purpleWeight) + 0.6 * purpleWeight;
                const g = 1.0 * (1 - purpleWeight) + 0.3 * purpleWeight;
                const b = 1.0 * (1 - purpleWeight) + 0.8 * purpleWeight;
                robot.recolor.set(r, g, b);
              } else {
                robot.recolor.set(1, 1, 1); // White default
              }
            }
          }
        }
      }
      
      // Handle forest disintegration animation
      if (forestMesh && forestMesh.clickedTimer > 0) {
        forestMesh.clickedTimer -= 1;
        
        if (forestMesh.isDisintegrating) {
          // Set start time on first frame of disintegration
          if (forestMesh.disintegrateStartTime === 0) {
            forestMesh.disintegrateStartTime = time / 1000;
            console.log("Forest disintegration started!");
          }
          
          // Update individual disintegration time (starts from 0 for forest)
          forestMesh.disintegrateTime.value = (time / 1000) - forestMesh.disintegrateStartTime;
          
          // Animate disintegration intensity from 0 to 1
          const progress = 1 - (forestMesh.clickedTimer / 360);
          forestMesh.disintegrateIntensity.value = Math.min(progress * 1.5, 1.0);
          
          if (forestMesh.clickedTimer % 60 === 0) { // Log every 60 frames
            console.log(`Forest disintegration progress: ${progress.toFixed(2)}, intensity: ${forestMesh.disintegrateIntensity.value.toFixed(2)}, timer: ${forestMesh.clickedTimer}`);
          }
          
          // Update shader
          if (forestMesh.updateGenerator) {
            forestMesh.updateGenerator();
          }
          if (forestMesh.updateVersion) {
            forestMesh.updateVersion();
          }
          
          if (forestMesh.clickedTimer == 0) {
            // Forest disintegration complete
            console.log("Forest completely disintegrated!");
            scene.remove(forestMesh);
            forestMesh = null;
          }
        }
      }
      
      // Update hover state every frame (after objects have moved)
      updateHoverState();
      
      renderer.render(scene, camera);
    });
    }

    // Initialize the application
    init().catch(console.error);
  </script>
</body>

</html>
