<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Spark â€¢ Raycasting</title>
  <style>
    body {
      margin: 0;
      /* Default cursor set via JavaScript for better control - 128x128 with finger tip hotspot */
      cursor: url('./assets/cursor/thanos_point_128.png') 32 16, pointer;
    }

    header {
      position: absolute;
      color: silver;
      font-family: sans-serif;
      padding-top: 20px;
      text-align: center;
      width: 100vw;
      z-index: 100;
    }

    canvas {
      cursor: inherit;
    }

  </style>
</head>

<body>
  <header>THANOS SPLAT<br>point at an object to select and click to delete<br><small id="loading-text">loading...</small></header>
  
  <script>
    // Hide loading text after 5 seconds
    setTimeout(() => {
      const loadingText = document.getElementById('loading-text');
      if (loadingText) {
        loadingText.style.display = 'none';
      }
    }, 5000);
  </script>
  
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.178.0/three.module.js",
        "@sparkjsdev/spark": "https://sparkjs.dev/releases/spark/0.1.9/spark.module.js"
      }
    }
  </script>
  <script type="module">
    import * as THREE from "three";
    import { SplatMesh, PackedSplats, dyno } from "@sparkjsdev/spark";


    async function init() {
    // Set default cursor immediately, then preload for better reliability
    document.body.style.cursor = `url('./assets/cursor/thanos_point_128.png') 32 16, pointer`;
    
    // Preload cursor to ensure it's cached
    const defaultCursorImg = new Image();
    defaultCursorImg.onload = () => {
      console.log('Default cursor preloaded successfully');
      // Re-apply cursor after preload to ensure it shows
      document.body.style.cursor = `url('./assets/cursor/thanos_point_128.png') 32 16, pointer`;
    };
    defaultCursorImg.onerror = () => {
      console.error('Failed to load default cursor, using fallback');
      document.body.style.cursor = 'pointer';
    };
    defaultCursorImg.src = './assets/cursor/thanos_point_128.png';
    
    // Animation time for shader effects
    const animateT = dyno.dynoFloat(0);
    
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 10);
    camera.position.set(0, -0.25, -1.5);
    camera.lookAt(0, -0.15, 0);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    window.addEventListener('resize', onWindowResize, false);
    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Add robots
    const NUM_ROBOTS = 3;
    const robots = [];
    
    // Load the local bear.ply file
    console.log("Loading local bear.ply file...");
    
    try {
      // Load the PLY file using Spark.js PackedSplats
      const splatURL = "./assets/bear.ply";
      const packedSplats = new PackedSplats({ url: splatURL });
      
      // Wait for the splats to load
      await packedSplats.ready;
      console.log("Bear PLY file loaded successfully");
      
      for (let i = 0; i < NUM_ROBOTS; i++) {
        const robot = new SplatMesh({ packedSplats });
        robot.rotation.x = Math.PI;
        robot.scale.setScalar(0.3); // Adjust scale for the bear
        robot.position.set((i - 1) * 1.6, 0, 2.0); // Position side by side at z=2.0, spaced 2x wider
        robot.baseX = (i - 1) * 1.6; // Store base X position for bobbing
        robot.speed = 600 + i * 10;
        robot.angle = 0;
        robot.clickedTimer = false;
        robot.disintegrateIntensity = dyno.dynoFloat(0); // Track disintegration effect
        robot.disintegrateTime = dyno.dynoFloat(0); // Individual time for this robot's disintegration
        robot.disintegrateStartTime = 0; // Track when disintegration started
        robot.isHovered = dyno.dynoFloat(0); // Track hover state for wobble effect
        // Bounding box will be passed as literal values
        
        // Add combined shader modifier (wobble + disintegration)
        robot.objectModifier = dyno.dynoBlock(
          { gsplat: dyno.Gsplat },
          { gsplat: dyno.Gsplat },
          ({ gsplat }) => {
            // First apply wobble effect for hover
            const wobble = new dyno.Dyno({
              inTypes: { 
                gsplat: dyno.Gsplat, 
                t: "float",
                hoverIntensity: "float"
              },
              outTypes: { gsplat: dyno.Gsplat },
              globals: () => [
                dyno.unindent(`
                  // Simple noise function for wobble
                  vec3 simpleHash(vec3 p) {
                    return fract(sin(p*123.456)*123.456);
                  }
                  
                  float simpleNoise(vec3 p) {
                    vec3 i = floor(p);
                    vec3 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    
                    return mix(
                      mix(mix(dot(simpleHash(i + vec3(0,0,0)), f - vec3(0,0,0)),
                              dot(simpleHash(i + vec3(1,0,0)), f - vec3(1,0,0)), f.x),
                          mix(dot(simpleHash(i + vec3(0,1,0)), f - vec3(0,1,0)),
                              dot(simpleHash(i + vec3(1,1,0)), f - vec3(1,1,0)), f.x), f.y),
                      mix(mix(dot(simpleHash(i + vec3(0,0,1)), f - vec3(0,0,1)),
                              dot(simpleHash(i + vec3(1,0,1)), f - vec3(1,0,1)), f.x),
                          mix(dot(simpleHash(i + vec3(0,1,1)), f - vec3(0,1,1)),
                              dot(simpleHash(i + vec3(1,1,1)), f - vec3(1,1,1)), f.x), f.y), f.z);
                  }

                  vec3 wobblePosition(vec3 pos, float t, float intensity) {
                    if (intensity <= 0.0) return pos;

                    vec3 npos = 0.1 * pos;
                    
                    float nt = t*10.0;
                    // Create turbulent wobble with multiple noise octaves - 10x higher frequency
                    vec3 wobble = vec3(
                      simpleNoise(npos * 80.0 + nt * 20.0),
                      simpleNoise(npos * 60.0 + nt * 15.0 + 100.0),
                      simpleNoise(npos * 100.0 + nt * 25.0 + 200.0)
                    ); // Zero-centered: [0,1] -> [-1,1]
                    
                    // Add some larger scale movement - also 10x higher frequency
                    // wobble += vec3(
                    //   simpleNoise(npos * 20.0 + t * 8.0),
                    //   simpleNoise(npos * 15.0 + t * 6.0 + 50.0),
                    //   simpleNoise(npos * 30.0 + t * 10.0 + 150.0)
                    // ) * 2.0 - 2.0; // Zero-centered: [0,1] -> [-1,1]
                    
                    // Ensure final wobble is zero-centered and scaled
                    return pos*1.1;// * (1.0+ wobble * intensity * 0.5); // wobble is already zero-centered
                  }
                `)
              ],
              statements: ({ inputs, outputs }) => dyno.unindentLines(`
                ${outputs.gsplat} = ${inputs.gsplat};
                
                // Apply wobble to position
                ${outputs.gsplat}.center = wobblePosition(${inputs.gsplat}.center, ${inputs.t}, ${inputs.hoverIntensity});
              `),
            });

            gsplat = wobble.apply({ 
              gsplat, 
              t: animateT,
              hoverIntensity: robot.isHovered
            }).gsplat;

            // Then apply disintegration effect
            const d = new dyno.Dyno({
              inTypes: { 
                gsplat: dyno.Gsplat, 
                t: "float", 
                intensity: "float"
              },
              outTypes: { gsplat: dyno.Gsplat },
              globals: () => [
                dyno.unindent(`
                  // Multi-octave noise function for natural variation
                  vec3 hash(vec3 p) {
                    return fract(sin(p*123.456)*123.456);
                  }
                  
                  float noise(vec3 p) {
                    vec3 i = floor(p);
                    vec3 f = fract(p);
                    f = f * f * (3.0 - 2.0 * f);
                    
                    return mix(
                      mix(mix(dot(hash(i + vec3(0,0,0)), f - vec3(0,0,0)),
                              dot(hash(i + vec3(1,0,0)), f - vec3(1,0,0)), f.x),
                          mix(dot(hash(i + vec3(0,1,0)), f - vec3(0,1,0)),
                              dot(hash(i + vec3(1,1,0)), f - vec3(1,1,0)), f.x), f.y),
                      mix(mix(dot(hash(i + vec3(0,0,1)), f - vec3(0,0,1)),
                              dot(hash(i + vec3(1,0,1)), f - vec3(1,0,1)), f.x),
                          mix(dot(hash(i + vec3(0,1,1)), f - vec3(0,1,1)),
                              dot(hash(i + vec3(1,1,1)), f - vec3(1,1,1)), f.x), f.y), f.z);
                  }

                  vec4 disintegrate(vec3 pos, float t, float intensity) {
                    // Calculate relative bounding box Y (equivalent to VEX relbbox.y) - using estimated bounds
                    float relbboxY = (pos.y + 0.5) / 1.0; // Assumes bbox from -0.5 to 0.5
                    relbboxY += noise(pos * 4.0 + t * 0.3);
                    t = max(0.0,(t * 0.3) - relbboxY*0.3 - 0.4);
                    // Create dissolve pattern that moves from bottom to top
                    float dissolveHeight = mix(-2.0, 2.0, intensity);
                    float dissolveProgress = smoothstep(dissolveHeight - 0.5, dissolveHeight + 0.5, pos.y);
                    
                    // Add noise variation to the dissolve pattern
                    float noiseVariation = noise(pos * 8.0 + t * 0.5) * 0.3;
                    dissolveProgress += noiseVariation;
                    dissolveProgress = clamp(dissolveProgress, 0.0, 1.0);
                    
                    // Wind direction: up and to the right (like Thanos effect)
                    vec3 windDirection = vec3(1.5, 1.0, 0.2); // Right, up, slight forward
                    
                    // Add turbulent noise to wind for natural variation
                    vec3 turbulence = vec3(
                      noise(pos * 4.0 + t * 0.8),
                      noise(pos * 3.0 + t * 0.6 + 100.0),
                      noise(pos * 5.0 + t * 0.4 + 200.0)
                    ) * 2.0 - 1.0;
                    
                    // Combine wind direction with turbulence
                    vec3 finalWind = windDirection * 1.0;// + turbulence * 0.8;
                    
                    // Apply wind displacement based on dissolve progress
                    vec3 windOffset = -finalWind * pow(t,1.2);// * intensity * 2.0;
                    vec3 newPos = pos + windOffset + pow(t,3.0) * turbulence * 2.0;
                    
                    // Fade out particles as they dissolve
                    float alpha = 1.0 - t;// - dissolveProgress;
                    //alpha += pow(t*100.0,-2.0);
                    
                    return vec4(newPos, alpha);
                  }
                `)
              ],
              statements: ({ inputs, outputs }) => dyno.unindentLines(`
                ${outputs.gsplat} = ${inputs.gsplat};
                
                vec3 localPos = ${inputs.gsplat}.center;
                
                // Apply disintegration effect
                if (${inputs.intensity} > 0.0) {
                  vec4 e = disintegrate(localPos, ${inputs.t}, ${inputs.intensity});
                  ${outputs.gsplat}.center = e.xyz;
                  
                  // Scale particles smaller as they dissolve and fade
                  float fadeAmount = 1.0 - e.w;
                  ${outputs.gsplat}.scales = mix(${inputs.gsplat}.scales, vec3(.01, .01, .01), fadeAmount);
                  
                  // Use the alpha from the disintegration function
                  ${outputs.gsplat}.rgba.a = ${inputs.gsplat}.rgba.a * e.w;
                  
                  // Add brief white flash when t < 0.05
                  if (${inputs.t} > 0.3 && ${inputs.t} < 0.35 && ${inputs.intensity} > 0.0) {
                    float flashIntensity = 1.0 - ((${inputs.t}-0.3) / 0.05); // 1.0 at t=0, 0.0 at t=0.05
                    ${outputs.gsplat}.rgba.rgb = mix(${inputs.gsplat}.rgba.rgb, vec3(1.0, 1.0, 1.0), flashIntensity*0.7);
                  }
                }
              `),
            });

            gsplat = d.apply({ 
              gsplat, 
              t: robot.disintegrateTime,
              intensity: robot.disintegrateIntensity
            }).gsplat;
            
            return { gsplat };
          }
        );
        
        scene.add(robot);
        robots.push(robot);
      }
      console.log(`Created ${NUM_ROBOTS} bear splat meshes`);
      
    } catch (error) {
      console.error("Error loading bear PLY:", error);
      // Fallback: create simple spheres if PLY loading fails
      for (let i = 0; i < NUM_ROBOTS; i++) {
        const geometry = new THREE.SphereGeometry(0.1, 16, 16);
        const material = new THREE.MeshBasicMaterial({ 
          color: new THREE.Color().setHSL(i / NUM_ROBOTS, 0.7, 0.6)
        });
        const robot = new THREE.Mesh(geometry, material);
        robot.position.set((i - 1) * 1.6, 0, 2.0); // Position side by side at z=2.0, spaced 2x wider
        robot.baseX = (i - 1) * 1.6; // Store base X position for bobbing
        robot.speed = 600 + i * 10;
        robot.angle = 0;
        robot.clickedTimer = false;
        robot.disintegrateIntensity = dyno.dynoFloat(0); // Track disintegration effect
        robot.disintegrateTime = dyno.dynoFloat(0); // Individual time for this robot's disintegration
        robot.disintegrateStartTime = 0; // Track when disintegration started
        robot.isHovered = dyno.dynoFloat(0); // Track hover state for wobble effect
        // Bounding box will be passed as literal values
        robot.recolor = { 
          set: (r, g, b, a = 1.0) => {
            robot.material.color.setRGB(r, g, b);
            robot.material.opacity = a;
            robot.material.transparent = a < 1.0;
          }
        };
        scene.add(robot);
        robots.push(robot);
      }
      console.log(`Created ${NUM_ROBOTS} fallback sphere meshes`);
    }

    // Cursor management with frame animation - 128x128 version
    let isSnapping = false;
    let snapFrameIndex = 0;
    let snapAnimationInterval = null;
    const totalSnapFrames = 25; // Now we have 25 frames
    
    function startSnapCursor() {
      if (isSnapping) return; // Prevent multiple snaps
      
      // Clear any existing interval first
      if (snapAnimationInterval) {
        clearInterval(snapAnimationInterval);
        snapAnimationInterval = null;
      }
      
      isSnapping = true;
      snapFrameIndex = 1; // Start with frame 1
      
      // Set initial frame - 128x128 with finger tip hotspot at 32,16
      document.body.style.cursor = `url('./assets/cursor/snap_frame_128_001.png') 32 16, pointer`;
      
      // Animate through frames
      snapAnimationInterval = setInterval(() => {
        snapFrameIndex++;
        if (snapFrameIndex <= totalSnapFrames) {
          const frameNum = snapFrameIndex.toString().padStart(3, '0');
          document.body.style.cursor = `url('./assets/cursor/snap_frame_128_${frameNum}.png') 32 16, pointer`;
        } else {
          // Animation complete, return to default
          clearInterval(snapAnimationInterval);
          snapAnimationInterval = null; // Clear the interval reference
          document.body.style.cursor = `url('./assets/cursor/thanos_point_128.png') 32 16, pointer`;
          isSnapping = false;
          console.log('Snap animation complete, cursor reset to default');
        }
      }, 80); // 80ms per frame for 25 frames = 2 second total animation
      
      // Fallback timeout to ensure cursor resets even if something goes wrong
      setTimeout(() => {
        if (isSnapping) {
          console.log('Fallback cursor reset triggered');
          if (snapAnimationInterval) {
            clearInterval(snapAnimationInterval);
            snapAnimationInterval = null;
          }
          document.body.style.cursor = `url('./assets/cursor/thanos_point_128.png') 32 16, pointer`;
          isSnapping = false;
        }
      }, 3000); // 3 second fallback (longer than the 2 second animation)
    }

    // Raycast logic
    const raycaster = new THREE.Raycaster();
    let hoveredObject = null;
    let currentMouseCoords = new THREE.Vector2();
    let mouseInCanvas = false;
    
    // Track mouse position for continuous raycasting
    renderer.domElement.addEventListener("mousemove", (event) => {
      // Adjust for cursor hotspot offset (finger tip is at 32,16, center would be 64,64)
      const offsetX = event.clientX - 32; // Move left by 32 pixels
      const offsetY = event.clientY - 48; // Move up by 48 pixels (64-16)
      
      currentMouseCoords.set(
        (offsetX / renderer.domElement.width) * 2 - 1,
        -(offsetY / renderer.domElement.height) * 2 + 1
      );
      mouseInCanvas = true;
    });
    
    // Track when mouse leaves canvas
    renderer.domElement.addEventListener("mouseleave", () => {
      mouseInCanvas = false;
      // Reset hover state when mouse leaves
      if (hoveredObject && !hoveredObject.clickedTimer) {
        hoveredObject.recolor.set(1, 1, 1);
      }
      hoveredObject = null;
    });
    
    // Function to perform hover detection (called every frame)
    function updateHoverState() {
      if (!mouseInCanvas) return;
      
      // Run raycaster for hover detection
      raycaster.setFromCamera(currentMouseCoords, camera);
      const hits = raycaster.intersectObjects(scene.children);

      // Find first SplatMesh
      const index = hits.findIndex(hit => hit.object instanceof SplatMesh);
      
      if (index >= 0) {
        const newHoveredObject = hits[index].object;
        
        // If we're hovering over a different object
        if (hoveredObject !== newHoveredObject) {
          // Reset previous hovered object (if not clicked)
          if (hoveredObject && !hoveredObject.clickedTimer) {
            hoveredObject.recolor.set(1, 1, 1); // Reset to white
            hoveredObject.isHovered.value = 0; // Stop wobble
          }
          
          // Set new hovered object to purple (if not clicked and not disintegrating)
          hoveredObject = newHoveredObject;
          if (!hoveredObject.clickedTimer && !hoveredObject.isDisintegrating) {
            // Blend purple with original white at 0.4 weight (40% purple, 60% white)
            const purpleWeight = 0.4;
            const r = 1.0 * (1 - purpleWeight) + 0.6 * purpleWeight;
            const g = 1.0 * (1 - purpleWeight) + 0.3 * purpleWeight;
            const b = 1.0 * (1 - purpleWeight) + 0.8 * purpleWeight;
            hoveredObject.recolor.set(r, g, b);
            hoveredObject.isHovered.value = 1.0; // Start wobble
          }
        }
      } else {
        // Not hovering over any object
        if (hoveredObject && !hoveredObject.clickedTimer) {
          hoveredObject.recolor.set(1, 1, 1); // Reset to white
          hoveredObject.isHovered.value = 0; // Stop wobble
        }
        hoveredObject = null;
      }
    }

    // Click handler
    renderer.domElement.addEventListener("click", (event) => {
      // Start the snap cursor animation
      startSnapCursor();
      
      // Adjust for cursor hotspot offset (same as mousemove)
      const offsetX = event.clientX - 32; // Move left by 32 pixels
      const offsetY = event.clientY - 48; // Move up by 48 pixels (64-16)
      
      const clickCoords = new THREE.Vector2(
        (offsetX / renderer.domElement.width) * 2 - 1,
        -(offsetY / renderer.domElement.height) * 2 + 1,
      );

      // Run raycaster
      raycaster.setFromCamera(clickCoords, camera);
      const hits = raycaster.intersectObjects(scene.children);

      // Find first SplatMesh
      const index = hits.findIndex(hit => hit.object instanceof SplatMesh);
      if (index >= 0) {
        const robot = hits[index].object;
        if (!robot.clickedTimer) {
          // Start disintegration effect
          robot.clickedTimer = 360; // 3x longer timer for disintegration
          robot.disintegrateIntensity.value = 0; // Start from 0
          robot.isDisintegrating = true;
          robot.disintegrateStartTime = 0; // Will be set in animation loop
          robot.isHovered.value = 0; // Stop wobble when clicked
        }
      }
    });

    // Main loop
    renderer.setAnimationLoop(function animate(time) {
      // Update animation time for shaders
      animateT.value = time / 1000;
      
      // Animate all robots with bobbing motion, and handle disintegration
      for (let robot of robots) {
        // Bobbing up and down motion (only if not disintegrating and not hovered)
        if (!robot.isDisintegrating && robot !== hoveredObject) {
          robot.position.y = Math.sin(time / robot.speed) * 0.3; // Bob up and down with 0.3 amplitude
          robot.position.x = robot.baseX; // Maintain horizontal position
        }
        
        // Slow inward spinning for left and right bears (not center)
        if (!robot.isDisintegrating) {
          if (robot.baseX < 0) {
            // Left bear - spin clockwise (positive rotation around Y axis)
            robot.rotation.y = (time / 5000) % (Math.PI * 2); // 5 second full rotation
          } else if (robot.baseX > 0) {
            // Right bear - spin counter-clockwise (negative rotation around Y axis)
            robot.rotation.y = -(time / 5000) % (Math.PI * 2); // 5 second full rotation
          }
          // Center bear (baseX === 0) doesn't spin
        }

        if (robot.clickedTimer > 0) {
          robot.clickedTimer -= 1;
          
          // Handle disintegration animation
          if (robot.isDisintegrating) {
            // Set start time on first frame of disintegration
            if (robot.disintegrateStartTime === 0) {
              robot.disintegrateStartTime = time / 1000;
            }
            
            // Update individual disintegration time (starts from 0 for each robot)
            robot.disintegrateTime.value = (time / 1000) - robot.disintegrateStartTime;
            
            // Animate disintegration intensity from 0 to 1
            const progress = 1 - (robot.clickedTimer / 360);
            robot.disintegrateIntensity.value = Math.min(progress * 1.5, 1.0);
            
            // Update shader
            if (robot.updateGenerator) {
              robot.updateGenerator();
            }
            if (robot.updateVersion) {
              robot.updateVersion();
            }
            
            if (robot.clickedTimer == 0) {
              // Disintegration complete - reset bear
              robot.disintegrateIntensity.value = 0;
              robot.disintegrateTime.value = 0;
              robot.disintegrateStartTime = 0;
              robot.isDisintegrating = false;
              
              // Reset to appropriate color
              if (robot.recolor) {
                if (robot === hoveredObject && !robot.isDisintegrating) {
                  // Blend purple with original white at 0.4 weight (40% purple, 60% white)
                  const purpleWeight = 0.4;
                  const r = 1.0 * (1 - purpleWeight) + 0.6 * purpleWeight;
                  const g = 1.0 * (1 - purpleWeight) + 0.3 * purpleWeight;
                  const b = 1.0 * (1 - purpleWeight) + 0.8 * purpleWeight;
                  robot.recolor.set(r, g, b);
                } else {
                  robot.recolor.set(1, 1, 1); // White default
                }
              }
            }
          } else if (robot.clickedTimer == 0) {
            // Non-disintegration timer expired, check hover state
            if (robot.recolor) {
              if (robot === hoveredObject && !robot.isDisintegrating) {
                // Blend purple with original white at 0.4 weight (40% purple, 60% white)
                const purpleWeight = 0.4;
                const r = 1.0 * (1 - purpleWeight) + 0.6 * purpleWeight;
                const g = 1.0 * (1 - purpleWeight) + 0.3 * purpleWeight;
                const b = 1.0 * (1 - purpleWeight) + 0.8 * purpleWeight;
                robot.recolor.set(r, g, b);
              } else {
                robot.recolor.set(1, 1, 1); // White default
              }
            }
          }
        }
      }
      
      // Update hover state every frame (after objects have moved)
      updateHoverState();
      
      renderer.render(scene, camera);
    });
    }

    // Initialize the application
    init().catch(console.error);
  </script>
</body>

</html>